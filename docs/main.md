# CRC_2023_SV_React_Docs

The Voyages-Frontend React App interfaces with the Voyages-API Django app.

We have attempted to adopt a factory model for as many of the components as possible, in order to allow for themes, collections, menus, etc. to be built on the fly with the addition or alteration of configuration files, which are saved as JSON in the utils folder.

# ROUTES AND ROUTE-LIKE REQUESTS

Using token-based authentication, it makes POST requests to retrieve data from several API endpoints that map fairly closely to the React app's routing structure

* API ENDPOINT --> REACT ROUTE (tp60, correct these for me?)
* voyage/ --> voyage/
* past/ --> past/
	* past/enslaved --> past/enslaved
	* past/enslaver --> past/enslaver
* blog/ --> TBD
* doc/ --> TBD
* geo/ --> N/A

These main data retrieval endpoints map fairly closely to the React app's routing structure:

![endpoint](./assets/endpoints.svg)

The results come back to this front-end application in the form of highly-serialized JSON that, by and large, represents the underlying ORM on the Django back-end side. This can be a bit clunky, of course, but it allows us to flexibly create react components that interact with the Django API on a per-field basis. These fields are presented using double-underscore notation (like dot notation), and they and their datatypes can be retrieved by making an OPTIONS call to any of the above API endpoints.

For instance, if we wanted only to retrieve Voyages that disembarked captives in Texas, we would do the following:

	POST: /voyage/
	{
	  "voyage_itinerary__imp_principal_region_slave_dis__geo_location__name" : ["Texas"]
	}

In fact, we built this app on a "collections" model, where the apps load configuration files that have base queries. So, for instance, the route /voyage/texas-bound has the above filter baked into its section of the VOYAGES_COLLECTIONS.json flat file.

# COMPONENT FACTORIES

Our components are built on the factory model in order to enable editors to change things like the structure of menus, tables, dropdown selectors, etc. The inputs into these components are laid out in json flatfiles in utils/flatfiles.

NOTE: We are having a bit of trouble de-duping our code, specifically:

* cascading menu
* table
* column selector

all need to be reduced to a single table, but the state seems to be carrying over -- so that when we use the same table component factory between voyages and past/enslaved or past/enslaver, we see the wrong endpoints and variables being used.

## Filter components

### Cascading Menu Factory

Filter menus are specified in the utils/flatfiles folder, with filenames like ```texas_filter_menu.json```. In these files, we lay out the hierarchy of the filter menu, and the django var names and data types of the individual variables that the user can filter on. For example:

	[...
		{
		"label": "Itinerary",
		"children": [
			{
				"var_name": "voyage__voyage_ship__ship_name",
				"type": "CharField",
				"label": "Ship Name"
			},
			{
				"var_name": "voyage__voyage_itinerary__imp_principal_place_of_slave_purchase__geo_location__value",
				"type": "GeoField",
				"label": "Place of embarkation"
			},
			...
		]},
		...
	]

When a user clicks on one of these filterable variables in the cascading menu, they see pop up a filter component generated by the appropriate component factory.

### Filter Component Factory

Based on the type of the variable as specified in the filter menu json flatfile, when a user clicks on that variable label, the appropriate component factory is created by feeding it the targeted endpoint and the variable name.

From that point on, the filter component that has been generated updates the Redux store to maintain the active variable filters that the user has selected. Currently, we only have 3 filter components:

* RangeSlider for numeric fields
* AutoComplete for text fields
* TreeSelect for places (To come)

Autocomplete remains in constant contact with its own, special sub-endpoint on the API in order to assist the user in quickly narrowing down their search. RangeSlider and TreeSelect only hit the API once, in order to populate the available choices.

![filtercomponentfactory](./assets/filtercomponentfactory.svg)

When these filter components are interacted with by the user, the selected values are pushed to the Redux store as k/v pairs, with the variable name being the key and the selected values being the values.

## Presentation Components

"Presentation" components are where the user sees the results of the queries they have made. Our presentation components

* Scatter Graph
* Bar Graph
* Pie Graph
* Table
* Map (to come)
	* Geo Sankeys
	* Animations
* Pivot Table (to come)

Presentation components subscribe to the Redux store, and update when its contents update. This allows the user to select a filter, begin using it, and immediately see the results of the presentation component update on the basis of their choices. All components on a given collection page subscribe to the same store.